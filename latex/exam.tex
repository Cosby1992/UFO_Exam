\documentclass{article}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{makecell}

\renewcommand\theadfont{\bfseries}


% 1’eren er sjov fordi I kan gøre lidt ala det med optimerings-opgaven, 
% dokumentere med flotte box-plots osv. Måske kan I finde en hurtigere 
% implementation, at sammenligne med.

% Emne: PriorityQueue i Java
%     Udforsk den inbyggede PriorityQueue i Java
%     Hvorfor er den ikke god? (kan ikke updatere entries, kun linære ændringer (ingen indbygget update() metode))
%     Big O notation
%     Måske en bedre måde at lave den på, eller i hvert fald ideer til forbedringer

% The Dark Side of Java's PriorityQueue
% The Missing Piece in Java's PriorityQueue
\title{Java PriorityQueue Class} 

\author{Anders Jacobsen, Dima Karaush}

\include{lstsettings}

\begin{document}
\maketitle

\begin{abstract}
    Java's PriorityQueue class have a bottleneck when you need to update values in the queue.
    Depending on the use and implementation, Java's PriorityQueue can add serious performance 
    issues when accessing the data using the poll() method.
    When updating a value in the queue, performance can be improved by more than 50\% compared 
    to Java's PriorityQueue implementation. Implementing your own version might remove this 
    bottleneck from your software. 
\end{abstract}

\section{Introduction}
Why did we choose this subject
This article will discuss Java's "Build-in" class \lstinline!PriorityQueue!. 
The interest for this topic has grown from an implmentation of a weighted graph 
in Java, which we found had a possible shortcomming for our use-case. The shortcomming was that to update
a value in the queue, we had to use a linear search (loop) through the queue to update 
a value within. That is fine on a small scale, but what if need to draw a graph of all the cities in the world? 
We believe that this has space for optimization and that is why this article explores this subject.


We are going to use a previously developed \lstinline{Timer} class.  


How will we work with the subject


\section{Scope}
What will be in this article
What will not be included in this article

\section{Problem}
\subsection{Background}
% There's no way to find an element in a heap, but to go through all the 
% elements, though pruning (Stop searching if a bigger node is reached) is possible. 
% Therefore a list will be used to make search possible
% 
\subsection{Problem Statement}
The questions we will try to solve 
Problemfomulering


\section{Analysis}
\subsection{Benchmark Method} % Cosby
This subsection will cover how we prepared and executed our benchmarks.
It will also touch the subject of what we are timing in the two implementations
of a PriorityQueue. We've followed Peter Sestofts approach to microbenchmarking in 
Java \cite{microbenchmarks}, we've used a combination of Mark5 and Mark3 
benchmarks with a few twists here and there. 
To make benchmarks, a Timer class is nessesary. We've designed the simplest
version possible to avoid interference from calculations in the Timer class.


\begin{lstlisting}[caption={Simple Timer class implementation},label={lst:timerclass}]
    public class Timer {
        private long start;

        public void start() {
            start = System.nanoTime();
        }

        public long step() {
            return System.nanoTime() - start;
        }
    }
\end{lstlisting}

This implementation enables us to process the times as nano seconds after 
the benchmarks and also to easily restart the timer.

In addition to the Timer class we have also implemented a TimerTracker class.
This class only consists of two lists that can contain the warmup and real 
benchmark times. Also a method for writing the optained times to a CSV\footnote{Comma Seperated Values Filestructure} file.
The CSV files will be used to explore the data later. 

\begin{lstlisting}[caption={Benchmark iterations}, label={lst:benchmarkiterations}]
    private static void benchmarkPriorityQueue(int warmupIterations, int iterations, TimeTracker tracker) {
        // Printing removed for simplicity
        // Warmup
        for (int i = 0; i < warmupIterations; i++) {
            tracker.addWarmupTime(pQueueRun());
        }
        // Benchmark
        for (int i = 0; i < iterations; i++) {
            tracker.addTime(pQueueRun());
        }
    }
\end{lstlisting}

%How do we measure the times
Measurements in the benchmark is done only on the time it takes to update 
a value in the PriorityQueue. Again we follow Peter Sestofts microbenchmarking 
techniques. In listing \ref{lst:benchmarkiterations} we run a number of warmup iterations before running the
actual benchmark. This is to fight the battle agains Java's JIT\footnote{Just In Time} 
compiler as described in Peter Sestofts article. In the listing the method 
\lstinline{pQueueRun()} is running the benchmark, this will be descriped 
in section \ref{sec:javabenchmark}. The \lstinline{tracker.addTime(long time)} 
simply adds a time to a list that will later be written to a CSV file.

%remember ref to pdf (peter sestoft i disc)
%Something about out Timer, TimerTracker class
%How do we measure the times
%What do we time (ONLY UPDATE)
%Why do we do as we do
\subsection{Benchmark of Java's priorityQueue} % Dima
\label{sec:javabenchmark}
%Describe the method for updating (LINEAR WITH ITERATOR)
To understand the example that we are using we have to take a look at how we use our queue.

\begin{lstlisting}[caption={Populating the queue},label={lst:Populating_the_queue}]
    PriorityQueue<Node> pQueue = new PriorityQueue<>(QUEUE_LENGTH, nodeComp);

    // Filling the queue with Nodes
    for (int i = 0; i < QUEUE_LENGTH; i++) {
        pQueue.add(new Node(i, i + 1, i));
    }
\end{lstlisting}

We create a simple priorityQueue that takes nodes as an object. Then we add some nodes that fill up the queue, 
the nodes do not have any special values. But we do add a unique values so that we are able to distinguish the nodes.

When were looking at updating a node in Java's priority queue. There is no method to retrieve the wanted node from the list.
Therefore we use a Iterator to list through every node in our list until we find a match.

\begin{lstlisting}[caption={Finding the node},label={lst:Finding_the_node}]
    Iterator<Node> it = pQueue.iterator();

    while (it.hasNext()) {
        n = it.next();
        if (count == QUEUE_LENGTH - 1) {
            n.verticeTo = 80085;
            time = timer.step();
            break;
        }
        count++;
    }
\end{lstlisting}

Notice that we are listing through the queue in a linear way. 
This is the reason that we are updating the last object in the queue, to simulate a worst case scenario.
% Show a desciption of our numbers

% Show boxplot of times
\subsection{Update Method} % Dima
% Descripe how we implemented our search 
% Descripe that we are NOT using a heap and maybe that our 
% PriorityQueue is MUCH slower than java, in everything but the update method
\subsection{Benchmark of updateable PriorityQueue} % Cosby
% Describe the method for updating (LINEAR WITH ITERATOR)
The way we benchmarked our implmentation of the PriorityQueue can be seen on listing \ref{lst:benchmark_of_selfpq}.

\begin{lstlisting}[caption={Benchmark implmentation on our PriorityQueue},label={lst:benchmark_of_selfpq}]
    private static long pQueueRun() {
        // Initialization removed for simplicity

        timer.start();
        Node n = queue.retrieve(new Node(500, 1000, QUEUE_LENGTH-1));
        n.verticeTo = 101;
        time = timer.step();

        return time;
    }
\end{lstlisting}

As seen on the listing we have removed the initializing for simplicity in the exapmle. 
So keep in mind that a new queue and timer are initialized every iteration in the benchmark. 
In the example it visible that we use our \lstinline{retrieve()} method to get a specific 
node from the queue. We then mutate a value on the node, and stop the timer. 
Afterwards the time is returned. Later in the benchmark, the returned time is being saved in the
\lstinline{TimerTracker} witch writes it to a CSV file. 

We have explored the data from the CSV file using a Python Notebook. This gave us the 
following inside. 

\begin{tabular}{|l|l|}
    \hline
    \thead[l]{OS}                      & Microsoft Windows 10 Pro \\ 
    \hline
    \thead[l]{OS Version}              & 10.0.19042 N/A Build 19042 \\  
    \hline
    \thead[l]{System Type}             & x64-based PC \\
    \hline
    \thead[l]{Processor(s)}            & \makecell[l]{Intel® Core™ i7-10700KF Processor, \\ 16M Cache, up to 5.10 GHz} \\
    \hline
    \thead[l]{BIOS Version}            & American Megatrends Inc. 1.10, 21-05-2020 \\
    \hline
    \thead[l]{Total Physical Memory}   & 32.688 MB \\ 
    \hline
    \thead[l]{Disc(s)}                 & \makecell[l]{Force Series™ MP510 980GB M.2 SSD \\ (up to 3480MB/sec sequencial read)} \\
    \hline
\end{tabular}




% Show a desciption of our numbers
% Show boxplot of times
\subsection{Comparisson of PriorityQueues} % Dima
% How much faster is the method than Javas
% Boxplots with comparrison

\section{Conclusion} % Cosby
Answer our questions and possibly introduction
% Something about how much faster our queue is at updating
% Something about how our results are to be taken with a grain of salt, 
% since our priority queue inserts elements linear, therefore it's much 
% slower at everything else in Java's PriorityQueue. 

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}