\documentclass{article}

\usepackage{listings}
\usepackage{xcolor}


% 1’eren er sjov fordi I kan gøre lidt ala det med optimerings-opgaven, 
% dokumentere med flotte box-plots osv. Måske kan I finde en hurtigere 
% implementation, at sammenligne med.

% Emne: PriorityQueue i Java
%     Udforsk den inbyggede PriorityQueue i Java
%     Hvorfor er den ikke god? (kan ikke updatere entries, kun linære ændringer (ingen indbygget update() metode))
%     Big O notation
%     Måske en bedre måde at lave den på, eller i hvert fald ideer til forbedringer

\author{Anders Jacobsen, Dima Karaush}

% The Dark Side of Java's PriorityQueue
% The Missing Piece in Java's PriorityQueue
\title{Java PriorityQueue Class} 

\include{lstsettings}

\begin{document}
\maketitle


\begin{abstract}
    Java's PriorityQueue class have a bottleneck when you need to update values in the queue.
    Depending on the use and implementation, Java's PriorityQueue can add serious performance 
    issues when accessing the data using the poll() method.
    When updating a value in the queue, performance can be improved by more than 50\% compared 
    to Java's PriorityQueue implementation. Implementing your own version might remove this 
    bottleneck from your software. 
\end{abstract}

\section{Introduction}
Why did we choose this subject
This article will discuss Java's "Build-in" class \lstinline!PriorityQueue!. 
The interest for this topic has grown from an implmentation of a weighted graph 
in Java, which we found had a possible shortcomming for our use-case. The shortcomming was that to update
a value in the queue, we had to use a linear search (loop) through the queue to update 
a value within. That is fine on a small scale, but what if need to draw a graph of all the cities in the world? 
We believe that this has space for optimization and that is why this article explores this subject.


We are going to use a previously developed \lstinline{Timer} class.  


How will we work with the subject


\section{Scope}
What will be in this article
What will not be included in this article

\section{Problem}
\subsection{Background}
% There's no way to find an element in a heap, but to go through all the 
% elements, though pruning (Stop searching if a bigger node is reached) is possible. 
% Therefore a list will be used to make search possible
% 
\subsection{Problem Statement}
The questions we will try to solve 
Problemfomulering


\section{Analysis}
\subsection{Benchmark Method} % Cosby
%remember ref to pdf (peter sestoft i disc)
%Something about out Timer, TimerTracker class
%How do we measure the times
%What do we time (ONLY UPDATE)
%Why do we do as we do
\subsection{Benchmark of Java's priorityQueue} % Dima
%Describe the method for updating (LINEAR WITH ITERATOR)
To understand the example that we are using we have to take a look at how we use our queue.

\begin{lstlisting}[caption={Populating the queue},label={lst:benchmark_original}]
    PriorityQueue<Node> pQueue = new PriorityQueue<>(QUEUE_LENGTH, nodeComp);

    // Filling the queue with Nodes
    for (int i = 0; i < QUEUE_LENGTH; i++) {
        pQueue.add(new Node(i, i + 1, i));
    }
\end{lstlisting}

We create a simple priorityQueue that takes nodes as an object. Then we add some nodes that fill up the queue, 
the nodes do not have any special values. But we do add a unique values so that we are able to distinguish the nodes.

When were looking at updating a node in Java's priority queue. There is no method to retrieve the wanted node from the list.
Therefore we use a Iterator to list through every node in our list until we find a match.

\begin{lstlisting}[caption={Finding the node},label={lst:benchmark_original}]
    Iterator<Node> it = pQueue.iterator();

    while (it.hasNext()) {
        n = it.next();
        if (count == QUEUE_LENGTH - 1) {
            n.verticeTo = 80085;
            time = timer.step();
            break;
        }
        count++;
    }
\end{lstlisting}

Notice that we are listing through the queue in a linear way. 
This is the reason that we are updating the last object in the queue, to simulate a worst case scenario.
% Show a desciption of our numbers

% Show boxplot of times
\subsection{Update Method} % Dima
% Descripe how we implemented our search 
% Descripe that we are NOT using a heap and maybe that our 
% PriorityQueue is MUCH slower than java, in everything but the update method
\subsection{Benchmark of updateable PriorityQueue} % Cosby
% Describe the method for updating (LINEAR WITH ITERATOR)
% Show a desciption of our numbers
% Show boxplot of times
\subsection{Comparisson of PriorityQueues} % Dima
% How much faster is the method than Javas
% Boxplots with comparrison

\section{Conclusion} % Cosby
Answer our questions and possibly introduction
% Something about how much faster our queue is at updating
% Something about how our results are to be taken with a grain of salt, 
% since our priority queue inserts elements linear, therefore it's much 
% slower at everything else in Java's PriorityQueue. 


    
\end{document}